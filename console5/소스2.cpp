#include <iostream>

using std::cout;
using std::cin;
using std::endl;
/*
	전처리기 :
	- 실행파일을 생성하는 과정에서 컴파일 하기 직전, 소스파일 내에 존재하는 선행 처리 지시문을
	처리 하는 작업.

	-전처리가 실행되면 각 코드 파일에서 지시자를 찾는다.
	ㄴ 지시자는 #으로 시작해서 줄바꿈으로 끝나느 코드.
	* 선행 처리를 위한 명령어에는 맨앞에 #기호가 붙는다는 공통점이 있다.
	* ex) #include, #pragma region/endregion
	
	C/C++ 코드를 실행하는 과정
	- 전처리기 > 컴파일러>어셈블러>링커
		- 1.전처리기(preprocessor):
			ㄴ헤더 파일 삽입, 코드의 주석 제거, 문법 검토, 매크로등을 치환하는 기능을 한다.
		- 2.컴파일러
			ㄴ 어셈블리 파일로 변환하는 작업
		- 3.어셈블러
			ㄴ 어셈블리 코드를 기계어(0or1)로 변환하여 obj파일을 생성한다.
		- 4.링커
			ㄴ 각각의 오브젝트 파일들을 묶어서 실행코드 파일로 변환한다.

			소스코드 ->파이너리 > 실행파일

			* 디테일
				1. 내가 작성한 소스파일은 먼저 소스파일 처리를 하는 선행 처리기를 거치고
				2. 컴파일되어
				3. 오브젝트 파일이 생성되고
				4. 링커에 의해 실행 파일이 만들어진다.

			# 선행 처리를 위한 명령
			- 전처리기문 = 전처리기 연산자
			- 파일 처리를 위한 전처리기 문
				1. #include
				#include<파일이름>
				ㄴ표준 라이브러리(미리 정의된 include폴더에서 파일을 찾는다)
				#include"파일 이름.hpp"
				ㄴ 사용자 정의 헤더 파일( 현재의 소스 코드가 저장되어 있는 폴더에서 먼저 찾고, 파일이 없다면
									미리 정의된 include폴더에서 파일을 찾는다.)
			- 형태 정의를 위한 전처리기 문
				1. #define : 사용빈도 압도적으로 높음
				ㄴ define 키워드는 매크로 상수 또는 매크로 함수를 정의하는 키워드
				2. #undef
				ㄴ 매크로를 해제해 주는 키워드

			- 조건부 컴파일 시리즈들.
			1. #if, #ifdef,#ifndef,#else,#elif,#endif
			
			#ifdef:식별자가 정의되어 있으면 참

			#ifndef:식별자가 정의되어 있지 않으면 참

			#endif: #if or #ifdef or #ifnedf에 대한 전처리기 부분을 종료.

			*코드 설계에서 잘 적용이 된다면 실행 속도에 따른 큰 이득을 볼 수 있다.
			*ㄴ 선택적 컴파일을 수행할것이기 때문에
			 
			-pragma 

			-컴파일러의 기능을 확장시킬 수 있게 나온 문법
			ㄴ 어떠한 동안/ 행위를 정해주기 위해 사용한다.

			-사용중인 컴파일러의 버전/os에 따라 동작 여부가 갈린다.
			ㄴ 윈도우 코드는 윈도우만/ 리눅스 코드는 리눅스만

			#pragma once: 링크가 수행될 때 헤더파일이 한번만 포함되게 한다.
			#pragma region >코드를 개요/축소가 가능하게 묶어주는 기능.
			#pragma endregion 
			#pragma message("Example_05_c.pp 수정금지)
			#ㄴ 컴파일 시 출력창에 메세지 출력
			ㄴ 주로 협업시/ 혹은 본인이 한 중요한 작업 까먹지 않게 기입할때 사용한다.
		
		매크로 상수를 정의할때 주의점;
		1. #define 문은 코드를 생성하는 명령이 아니며, 매크로의 이름도 일종의 명칭이기 때문에.
		명칭 규칙에 맞게 작성해야 한다.
		2. 매크로 이름에는 공백이 들어갈 수 없지만 매크로 실제 값은 공백을 가질 수 있다.
		 ㄴ #define MESSAGE"똑바로 합시다."
		3. 문자열 상수내에 있는 매크로나 다른 명칭의 일부로 포함된 경우는 치환되지 않는다.
		 ㄴ #define NUM 5 -> NUM을 찾아 5로 치환
		4. 매크로는 중첩이 가능
		 ㄴ #define A 3 
		    #define B (A*3)
		5. 값을 가지지 않는 빈 매크로도 정의 가능
		  #define AAA ->값 자체가 없기 때문에 매크로 상수 장체만 존재할 뿐이다.
		6. 매크로 상수는 단순히 컴파일 전에 코드를 튜닝하는 전처리기에 의해서 처리되는 상수이기 때문에
			컴파일러 입장에서는 리터럴 상수와 동일 시 된다.
			ㄴ 컴파일러는 매크로 상수의 존재를 알지 못한다.
		7. 
*/		
// 매크로 정의 : #define 매크로명 실제값
#pragma message("Example_05_c.pp 수정금지")
#define EXAMPLE_1 1
#define EXAMPLE_2 1
//  ㄴ 매크로의 표기법은 대문자+스네이크

#undef EXAMPLE_2
#define EXAMPLE_2 2

//c언어 스타일
#define TRUE 1
#define FALSE 0

#define ADD(a) ((a)*(a))
void GetMultipleValue(int numA);
void main()

{	
	cout << ADD(5) << endl;
	GetMultipleValue(5);

#ifdef EXAMPLE_1
	cout << "1번 예시 출력" << endl;
#endif//End Of EXAMple_1

#if (EXAMPLE_2 ==1)  // 애초에 거짓이기 때문에 조건부 컴파일로서 읽어들이지 않아서 회색으로 나타남.
		cout << "2번 예시 출력" << endl;
#elif EXAMPLE_3
cout << "3번 예시 출력" << endl;
#elif(EXAMPLE_2==2)
cout << "4번 예시 출력" << endl;
#endif // End Of EXAMPLE_2
}
void GetMultipleValue(int numA) {
	cout << numA * numA << endl;
}


/*
 과제1. 가위바위보
 - 스위치문을 이용해 만든다.
 - 치트 기능과 배팅 기능을 추가
 ㄴ 초기 소지금 : 10,000원
 ㄴ 최소 배팅 : 1,000원

 5판을 하거나 내가 가진돈을 전부 잃으면 게임 종료

 이기면 판돈의 3배를 얻고 지면 판돈의 7배를 잃는다.
 비길경우 판돈의 5배를 얻는다.

 과제 2.숫자 야구
 0~9까지의 숫자중 컴퓨터가 임의로 3개를 뽑는다.
 컴퓨터가 뽑은 숫자를 플레이어가 임의의 숫자3개를 선택하여 숫자와 자리수 까지 맞추는 게임
 1. 선택한 숫자가 컴퓨터 숫자와 같으나 자리수가 다를경우 1볼
 2. 선택한 숫자가 컴퓨터 숫자와 같고, 자리수까지 같을 경우 1S
 3. 선택한 숫자가 하나도 해당되지 않을때 1아웃

 -이렇게 한턴에 3S만들 경우 몇번만에 맞췄는지 결과를 보여주면 게임은 끝난다.
 -필수: 치트
 ㄴ 배열X 

 타임 어택. 가위바위보(IF)
 -  주어진 시간안에 가위바위보 로직을 작성 후 실행하여 정상 동작되면 OK
 ㄴ 반에서 3명이상 실패시 매 과제마다 타임어택이 추가될 것이니 열심히 해온다.
 ㄴ 성공을 못한 인원은 3*못한 인원수 = 깜지
 
 한줄 조사. 배열+포인터

 - 노트에 적어온다.
 - 비유할 것 생각해 온다.
 


*/