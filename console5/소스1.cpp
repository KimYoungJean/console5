#include<iostream>

using std::cout;
using std::endl;

/* 
상수란

변수와 달리 저장된 데이터를 변경할 수 없는 공간에 붙여진 이름을 의미한다.
ㄴ상수는 한번 데이터가 저장되고 나면 변경하는 것이 일반적으로는 불가능하다.

*상수의 종류

- 리터럴 상수(이름이 없는 상수)
ㄴ 이름이 없는 상수라고 하며 임시 값이라고도 지칭한다.
ex): 1, 3.14 , 'c'등등...

문자 그 자체로서 존재하는 애들임 (1은 그냥 뜻이 1임, c도 그냥 문자 c일 뿐임) 이름이 없는 상수이기때문에 따로 불러올수 있는 수단이 없다.
이름이 따로 없어서 메모리에 넣을 필요도 없음.

- 심볼릭 상수(이름이 존재하는 상수)
ㄴ 심볼릭 상수는 const 라는 키워드를 통해서 선언이 가능하고 리터럴 상수와 달리 이름을 통해서
안에 저장되어 있는 데이터를 읽어들이는 것이 가능하다.
ex): const 한정자를 통해 만들어진 변수/ 네이밍
 ㄴ int num = 100; => const int number = 100;
 ㄴ const는 런타임 직전에 (콘솔창이 뜨기 바로 이전) 값이 결정됨

 constexpr
 - 이 키워드는 c++11에서 추가됐다.
 ㄴ 객체나 함수 앞에 붙일 수 있는 키워드로 해당 객체나 함수의 반환값을 컴파일 타임에 할 수 있다.
 ㄴ c++17부터는 람다식에 적용가능

 * 무엇보다 컴파일 타임에 값이 결정되므로 함수 호출간 템플릿 인자로 넘겨줄 때 아주 유용하다.
 * 
 c/c++은 기본적으로 컴파일러이기 때문에 상시 컴파일이 이루어진다. 컴파일속도가 매우빠른것이 장점이지만 상시 켜져있기때문에 메모리 사용량이 높다.
 컴파러는 링커에게 obj파일을 돌려얻기 전까지는 코드를 전체적으로 다 읽어버림
 - const/ consterxpr의 차이점?
 - 초기화 여부/ 오류 발견시기

ㄴ 런타임 이전까지 지연시킬 수 있느냐/ 컴파일 타임에 잡아 낼 수 있느냐의 차이
ㄴ 프로젝트가 크기가 커지면 실행버튼 부터 런타임까지의 시간이 오래걸리기 떄문에 오류를 찾을때 오래걸린다.
- 따라서 컴파일 타임에 찾을수만 있다면 개발시간 단축이 크게 이루어질 수 있다.


 상수는 초기화가 될때 값이 확정되어야함 따라서 할당으로는 쓸수 없음.



 > Readonly
 -- c#에서 지원하는 상수화 키워드
 
 const VS readonly
 const
 ㄴ 초기화 이후 값을 변경할 수 없다.
 ㄴ 선언하는 시점에만 초기화가 가능
 ㄴ 컴파일 타임 상수

 readonly
 ㄴ 초기화 이후 값을 변경할 수 없다.
 ㄴ 단, 선언하는 시점과 생성자에서 초기화가 1번 가능하다.
 ㄴ 런타임 상수

 * 컴파일 타임 상수는 변수가 실제 값으로 대체가 되고 
 * 런타임 상수는 변수의 참조 형식이기 때문에
 * 성능과 속도를 고려하면 const> readonly
 * 하지만 인스턴스마다 다른값을 할당하고 싶으면 || 사용자 정의 자료형 => readonly

 * define vs const (??)
 * 이건 전처리기 하고 나서 ..
 * 메모리 할당 여부
 * 리터럴/심볼릭
 * / #define은 메모리를 차지 하지 않는다. const는 메모리를 할당 받고
 * #define은 데이터가 저장된 메모리 공간을 가르키는 리터럴 상수이며 별도의 메모리를 할당하지 않는다.
 * const는 심볼릭 상수로 별도의 메모리를 할당받는 변수이므로 타입을 지정해 줘야한다.
 * ㄴ 스택 영역이라는 곳에 할당되기 때문에 필드(내가 속해있는 중괄호 영역)가 종료되면 메모리가 해제된다.
 * ㄴ 또한 타입체크가 발생하기 때문에 컴파일 과정에서 타입에 대한 오류를 확인할 수 있다.	
 * 
 * - 하나 더 얘기하자면 const의 경우 initializer를 ㅅ...
 * 
 * 유지보수를 중요한다면 const를 사용하고 메모리를 신경쓴다면 define을 사용.
 * define은 별도로 타입을 지정해주지 않기때문에 나중에 별도의 tracking하기가 어려울 수 있다.
*/

void main() {
	//pass
	const int number = 100;
	
	constexpr int number1= 100;
	
	//상수라는것은 초기화는 가능하지만 선언만 하고 나중에 할당할수는 없다
	// 기본적으로 선언과 동시에 값이 메모리에 입력이 되어야하기 때문에.

	cout << "==리터럴 상수==" << endl;
	cout << "정수형:" << 10<<","<<10l<<","<<10ll<<endl;

	cout << "실수형:" << 3.14f << "," << 3.14 << endl;
	cout << "문자형:" << 'A' << endl;

	printf("=n");

	cout << "== 심볼릭 상수==" << endl;
	const int nValue = 0;
	const float fValueA = 3.14f;
	const double dbValueA = 3.14;

	// cout<<"출력값:" << nValue
	printf("%d,%f,%lf\n,nValue,fValueA,dbValueA");

	//* 손코딩/문답식(5지선다)*

	const int cNumberA = 100;  // 차이 없음 변수의 상수화.
	int const cNumberB = 200;  // 동일한 기능
	const int* cNumberC;       // *:c언어 문법 -> 포인터 // 변수명이 가리키는 주소의 값을 변경할 수 없다.(주소 상수화)

	int pNum;

	// 포인터 변수의 상수화
	int* const cNumberD = &pNum;
	// 변수명이 가리키는 주소와 그 주소의 값도 상수화
	const int* const cNumberE = &pNum;


	

}

/*


*/